{-# OPTIONS --without-K --safe #-}

open import Algebra

module Data.FingerTree.Measures
  {r m}
  (ℳ : Monoid r m)
  where

open import Level using (_⊔_)

open Monoid ℳ renaming (Carrier to 𝓡)
open import Data.List as List using (List; _∷_; [])
open import Data.Product
open import Function

-- | A measure.
record σ {a} (Σ : Set a) : Set (a ⊔ r) where field μ : Σ → 𝓡
open σ ⦃ ... ⦄
{-# DISPLAY σ.μ _ = μ #-}

instance
  σ-List : ∀ {a} {Σ : Set a} → ⦃ _ : σ Σ ⦄ → σ (List Σ)
  μ ⦃ σ-List ⦄ = List.foldr (_∙_ ∘ μ) ε

record ⟪_⟫ {a} (Σ : Set a) ⦃ _ : σ Σ ⦄ : Set (a ⊔ r ⊔ m) where
  constructor μ⟨_⟩≈_⟨_⟩
  field
    𝓢 : Σ
    𝔐 : 𝓡
    .μ⟨𝓢⟩≈𝔐 : μ 𝓢 ≈ 𝔐
open ⟪_⟫ public

⟪_⇓⟫ : ∀ {a} {Σ : Set a} ⦃ _ : σ Σ ⦄ → Σ → ⟪ Σ ⟫
𝓢 ⟪ x ⇓⟫ = x
𝔐 ⟪ x ⇓⟫ = μ x
μ⟨𝓢⟩≈𝔐 ⟪ x ⇓⟫ = refl

instance
  σ-⟪⟫ : ∀ {a} {Σ : Set a} ⦃ _ : σ Σ ⦄ → σ ⟪ Σ ⟫
  μ ⦃ σ-⟪⟫ ⦄ = 𝔐

-- -- A "fiber" (I think) from the μ function.
-- --
-- -- μ⟨ Σ ⟩≈ 𝓂 means "There exists a Σ such that μ Σ ≈ 𝓂"
-- infixl 2 _⇑[_]
-- record μ⟨_⟩≈_ {a} (Σ : Set a) ⦃ _ : σ Σ ⦄ (𝓂 : 𝓡) : Set (a ⊔ r ⊔ m) where
--   constructor _⇑[_]
--   field
--     𝓢 : Σ
--     𝒻 : μ 𝓢 ≈ 𝓂
-- open μ⟨_⟩≈_ public

-- -- Construct a measured value without any transformations of the measure.
-- infixl 2 _⇑
-- _⇑ : ∀ {a} {Σ : Set a} ⦃ _ : σ Σ ⦄ (𝓢 : Σ) → μ⟨ Σ ⟩≈ μ 𝓢
-- 𝓢 (x ⇑) = x
-- 𝒻 (x ⇑) = refl
-- {-# INLINE _⇑ #-}

-- -- These combinators allow for a kind of easoning syntax over the measures.
-- -- The first is used like so:
-- --
-- --   xs ≈[ assoc _ _ _ ]
-- --
-- -- Which will have the type:
-- --
-- --   μ⟨ Σ ⟩≈ x ∙ y ∙ z → μ⟨ Σ ⟩≈ (x ∙ y) ∙ z
-- --
-- -- The second does the same:
-- --
-- --   xs ≈[ assoc _ _ _ ]′
-- --
-- -- However, when used in a chain, it typechecks after the ones used to its
-- -- left. This means you can call the solver on the left.
-- --
-- --   xs ≈[ ℳ ↯ ] ≈[ assoc _ _ _ ]′
-- infixl 2 _≈[_] ≈-rev
-- _≈[_] : ∀ {a} {Σ : Set a} ⦃ _ : σ Σ ⦄ {x : 𝓡} → μ⟨ Σ ⟩≈ x → ∀ {y} → x ≈ y → μ⟨ Σ ⟩≈ y
-- 𝓢 (xs ≈[ y≈z ]) = 𝓢 xs
-- 𝒻 (xs ≈[ y≈z ]) = trans (𝒻 xs) y≈z
-- {-# INLINE _≈[_] #-}

-- ≈-rev : ∀ {a} {Σ : Set a} ⦃ _ : σ Σ ⦄ {x : 𝓡} → ∀ {y} → x ≈ y → μ⟨ Σ ⟩≈ x → μ⟨ Σ ⟩≈ y
-- 𝓢 (≈-rev y≈z xs) = 𝓢 xs
-- 𝒻 (≈-rev y≈z xs) = trans (𝒻 xs) y≈z
-- {-# INLINE ≈-rev #-}

-- syntax ≈-rev y≈z x↦y = x↦y ≈[ y≈z ]′

-- infixr 2 ≈-right
-- ≈-right : ∀ {a} {Σ : Set a} ⦃ _ : σ Σ ⦄ {x : 𝓡} → μ⟨ Σ ⟩≈ x → ∀ {y} → x ≈ y → μ⟨ Σ ⟩≈ y
-- ≈-right (x ⇑[ x≈y ]) y≈z = x ⇑[ trans x≈y y≈z ]

-- syntax ≈-right x x≈ = [ x≈ ]≈ x

-- infixr 1 _↤_
-- -- A memoized application of μ
-- record ⟪_⟫ {a} (Σ : Set a) ⦃ _ : σ Σ ⦄ : Set (a ⊔ r ⊔ m) where
--   constructor _↤_
--   field
--     𝔐 : 𝓡
--     𝓕 : μ⟨ Σ ⟩≈ 𝔐
-- open ⟪_⟫ public

-- -- Construct the memoized version
-- ⟪_⇓⟫ : ∀ {a} {Σ : Set a} ⦃ _ : σ Σ ⦄ → Σ → ⟪ Σ ⟫
-- 𝔐 ⟪ x ⇓⟫ = μ x
-- 𝓕 ⟪ x ⇓⟫ = x ⇑


-- open import Algebra.FunctionProperties _≈_

-- -- This section allows us to use the do-notation to clean up proofs.
-- -- First, we construct arguments:
-- infixl 2 arg-syntax
-- record Arg {a} (Σ : Set a) ⦃ _ : σ Σ ⦄ (𝓂 : 𝓡) (f : 𝓡 → 𝓡) : Set (m ⊔ r ⊔ a) where
--   constructor arg-syntax
--   field
--     ⟨f⟩ : Congruent₁ f
--     arg : μ⟨ Σ ⟩≈ 𝓂
-- open Arg

-- syntax arg-syntax (λ sz → e₁) xs = xs [ e₁ ⟿ sz ]
-- -- This syntax is meant to be used like so:
-- --
-- --   do x ← xs [ a ∙> (s <∙ b) ⟿ s ]
-- --
-- -- And it means "the size of the variable I'm binding here will be stored in this
-- -- part of the expression". See, for example, the listToTree function:
-- --
-- --   listToTree [] = empty ⇑
-- --   listToTree (x ∷ xs) = [ ℳ ↯ ]≈ do
-- --     ys ← listToTree xs [ μ x ∙> s ⟿ s ]
-- --     x ◂ ys
-- --
-- infixl 1 _>>=_
-- _>>=_ : ∀ {a b} {Σ₁ : Set a} {Σ₂ : Set b} ⦃ _ : σ Σ₁ ⦄ ⦃ _ : σ Σ₂ ⦄ {𝓂 f}
--       → Arg Σ₁ 𝓂 f
--       → ((x : Σ₁) → ⦃ x≈ : μ x ≈ 𝓂 ⦄ → μ⟨ Σ₂ ⟩≈ f (μ x))
--       → μ⟨ Σ₂ ⟩≈ f 𝓂
-- arg-syntax cng xs >>= k = k (𝓢 xs) ⦃ 𝒻 xs ⦄ ≈[ cng (𝒻 xs) ]
-- {-# INLINE _>>=_ #-}

-- -- Inside the lambda generated by do notation, we can only pass one argument.
-- -- So, to provide the proof (if needed)
-- _≈?_ : ∀ x y → ⦃ x≈y : x ≈ y ⦄ → x ≈ y
-- _≈?_ _ _ ⦃ x≈y ⦄ = x≈y
